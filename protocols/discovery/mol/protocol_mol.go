// Generated by Molecule 0.6.0

package protocol

import (
	"bytes"
	"encoding/binary"
	"errors"
	"strconv"
	"strings"
)

type Number uint32

const HeaderSizeUint uint32 = 4

// Byte is the primitive type
type Byte [1]byte

func NewByte(b byte) Byte {
	return Byte([1]byte{b})
}
func ByteDefault() Byte {
	return Byte([1]byte{0})
}
func ByteFromSliceUnchecked(slice []byte) *Byte {
	b := new(Byte)
	b[0] = slice[0]
	return b
}
func (b *Byte) AsSlice() []byte {
	return b[:]
}
func ByteFromSlice(slice []byte, _compatible bool) (*Byte, error) {
	if len(slice) != 1 {
		return nil, errors.New("TotalSizeNotMatch")
	}
	b := new(Byte)
	b[0] = slice[0]
	return b, nil
}
func unpackNumber(b []byte) Number {
	bytesBuffer := bytes.NewBuffer(b)
	var x Number
	binary.Read(bytesBuffer, binary.LittleEndian, &x)
	return x
}
func packNumber(num Number) []byte {
	b := make([]byte, 4)
	binary.LittleEndian.PutUint32(b, uint32(num))
	return b
}

type BytesBuilder struct {
	inner []Byte
}

func (s *BytesBuilder) Build() Bytes {
	size := packNumber(Number(len(s.inner)))

	b := new(bytes.Buffer)

	b.Write(size)
	len := len(s.inner)
	for i := 0; i < len; i++ {
		b.Write(s.inner[i].AsSlice())
	}

	sb := Bytes{inner: b.Bytes()}

	return sb
}

func (s *BytesBuilder) Set(v []Byte) *BytesBuilder {
	s.inner = v
	return s
}
func (s *BytesBuilder) Push(v Byte) *BytesBuilder {
	s.inner = append(s.inner, v)
	return s
}
func (s *BytesBuilder) Extend(iter []Byte) *BytesBuilder {
	for i := 0; i < len(iter); i++ {
		s.inner = append(s.inner, iter[i])
	}
	return s
}

func NewBytesBuilder() *BytesBuilder {
	return &BytesBuilder{[]Byte{}}
}

type Bytes struct {
	inner []byte
}

func BytesFromSliceUnchecked(slice []byte) *Bytes {
	return &Bytes{inner: slice}
}
func (s *Bytes) AsSlice() []byte {
	return s.inner
}

func BytesDefault() Bytes {
	return *BytesFromSliceUnchecked([]byte{0, 0, 0, 0})
}

func BytesFromSlice(slice []byte, _compatible bool) (*Bytes, error) {
	sliceLen := len(slice)
	if sliceLen < int(HeaderSizeUint) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "Bytes", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}
	itemCount := unpackNumber(slice)
	if itemCount == 0 {
		if sliceLen != int(HeaderSizeUint) {
			errMsg := strings.Join([]string{"TotalSizeNotMatch", "Bytes", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(HeaderSizeUint))}, " ")
			return nil, errors.New(errMsg)
		}
		return &Bytes{inner: slice}, nil
	}
	totalSize := int(HeaderSizeUint) + int(1*itemCount)
	if sliceLen != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "Bytes", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}
	return &Bytes{inner: slice}, nil
}

func (s *Bytes) TotalSize() uint {
	return uint(HeaderSizeUint) * (s.ItemCount() + 1)
}
func (s *Bytes) ItemCount() uint {
	number := uint(unpackNumber(s.inner))
	return number
}
func (s *Bytes) Len() uint {
	return s.ItemCount()
}
func (s *Bytes) IsEmpty() bool {
	return s.Len() == 0
}

// if *Byte is nil, index is out of bounds
func (s *Bytes) Get(index uint) *Byte {
	var re *Byte
	if index < s.Len() {
		start := uint(HeaderSizeUint) + 1*index
		end := start + 1
		re = ByteFromSliceUnchecked(s.inner[start:end])
	}
	return re
}

func (s *Bytes) RawData() []byte {
	return s.inner[HeaderSizeUint:]
}

func (s *Bytes) AsBuilder() BytesBuilder {
	size := s.ItemCount()
	t := NewBytesBuilder()
	for i := uint(0); i < size; i++ {
		t.Push(*s.Get(i))
	}
	return *t
}

type BytesVecBuilder struct {
	inner []Bytes
}

func (s *BytesVecBuilder) Build() BytesVec {
	itemCount := len(s.inner)

	b := new(bytes.Buffer)

	// Empty dyn vector, just return size's bytes
	if itemCount == 0 {
		b.Write(packNumber(Number(HeaderSizeUint)))
		return BytesVec{inner: b.Bytes()}
	}

	// Calculate first offset then loop for rest items offsets
	totalSize := HeaderSizeUint * uint32(itemCount+1)
	offsets := make([]uint32, 0, itemCount)
	offsets = append(offsets, totalSize)
	for i := 1; i < itemCount; i++ {
		totalSize += uint32(len(s.inner[i-1].AsSlice()))
		offsets = append(offsets, offsets[i-1]+uint32(len(s.inner[i-1].AsSlice())))
	}
	totalSize += uint32(len(s.inner[itemCount-1].AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < itemCount; i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	for i := 0; i < itemCount; i++ {
		b.Write(s.inner[i].AsSlice())
	}

	return BytesVec{inner: b.Bytes()}
}

func (s *BytesVecBuilder) Set(v []Bytes) *BytesVecBuilder {
	s.inner = v
	return s
}
func (s *BytesVecBuilder) Push(v Bytes) *BytesVecBuilder {
	s.inner = append(s.inner, v)
	return s
}
func (s *BytesVecBuilder) Extend(iter []Bytes) *BytesVecBuilder {
	for i := 0; i < len(iter); i++ {
		s.inner = append(s.inner, iter[i])
	}
	return s
}

func NewBytesVecBuilder() *BytesVecBuilder {
	return &BytesVecBuilder{[]Bytes{}}
}

type BytesVec struct {
	inner []byte
}

func BytesVecFromSliceUnchecked(slice []byte) *BytesVec {
	return &BytesVec{inner: slice}
}
func (s *BytesVec) AsSlice() []byte {
	return s.inner
}

func BytesVecDefault() BytesVec {
	return *BytesVecFromSliceUnchecked([]byte{4, 0, 0, 0})
}

func BytesVecFromSlice(slice []byte, compatible bool) (*BytesVec, error) {
	sliceLen := len(slice)

	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "BytesVec", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "BytesVec", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint {
		return &BytesVec{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "BytesVec", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if offsetFirst%4 != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "BytesVec", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	itemCount := offsetFirst/4 - 1
	headerSize := HeaderSizeUint * (uint32(itemCount) + 1)
	if uint32(sliceLen) < headerSize {
		errMsg := strings.Join([]string{"HeaderIsBroken", "BytesVec", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(headerSize))}, " ")
		return nil, errors.New(errMsg)
	}

	offsets := make([]uint32, itemCount)

	for i := 0; i < int(itemCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][4*i:]))
	}

	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			errMsg := strings.Join([]string{"OffsetsNotMatch", "BytesVec"}, " ")
			return nil, errors.New(errMsg)
		}
	}

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 {
			start := offsets[i-1]
			end := offsets[i]
			_, err := BytesFromSlice(slice[start:end], compatible)

			if err != nil {
				return nil, err
			}
		}
	}

	return &BytesVec{inner: slice}, nil
}

func (s *BytesVec) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *BytesVec) ItemCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *BytesVec) Len() uint {
	return s.ItemCount()
}
func (s *BytesVec) IsEmpty() bool {
	return s.Len() == 0
}

// if *Bytes is nil, index is out of bounds
func (s *BytesVec) Get(index uint) *Bytes {
	var b *Bytes
	if index < s.Len() {
		start_index := uint(HeaderSizeUint) * (1 + index)
		start := unpackNumber(s.inner[start_index:])

		if index == s.Len()-1 {
			b = BytesFromSliceUnchecked(s.inner[start:])
		} else {
			end_index := start_index + uint(HeaderSizeUint)
			end := unpackNumber(s.inner[end_index:])
			b = BytesFromSliceUnchecked(s.inner[start:end])
		}
	}
	return b
}

func (s *BytesVec) AsBuilder() BytesVecBuilder {
	size := s.ItemCount()
	t := NewBytesVecBuilder()
	for i := uint(0); i < size; i++ {
		t.Push(*s.Get(i))
	}
	return *t
}

type NodeVecBuilder struct {
	inner []Node
}

func (s *NodeVecBuilder) Build() NodeVec {
	itemCount := len(s.inner)

	b := new(bytes.Buffer)

	// Empty dyn vector, just return size's bytes
	if itemCount == 0 {
		b.Write(packNumber(Number(HeaderSizeUint)))
		return NodeVec{inner: b.Bytes()}
	}

	// Calculate first offset then loop for rest items offsets
	totalSize := HeaderSizeUint * uint32(itemCount+1)
	offsets := make([]uint32, 0, itemCount)
	offsets = append(offsets, totalSize)
	for i := 1; i < itemCount; i++ {
		totalSize += uint32(len(s.inner[i-1].AsSlice()))
		offsets = append(offsets, offsets[i-1]+uint32(len(s.inner[i-1].AsSlice())))
	}
	totalSize += uint32(len(s.inner[itemCount-1].AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < itemCount; i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	for i := 0; i < itemCount; i++ {
		b.Write(s.inner[i].AsSlice())
	}

	return NodeVec{inner: b.Bytes()}
}

func (s *NodeVecBuilder) Set(v []Node) *NodeVecBuilder {
	s.inner = v
	return s
}
func (s *NodeVecBuilder) Push(v Node) *NodeVecBuilder {
	s.inner = append(s.inner, v)
	return s
}
func (s *NodeVecBuilder) Extend(iter []Node) *NodeVecBuilder {
	for i := 0; i < len(iter); i++ {
		s.inner = append(s.inner, iter[i])
	}
	return s
}

func NewNodeVecBuilder() *NodeVecBuilder {
	return &NodeVecBuilder{[]Node{}}
}

type NodeVec struct {
	inner []byte
}

func NodeVecFromSliceUnchecked(slice []byte) *NodeVec {
	return &NodeVec{inner: slice}
}
func (s *NodeVec) AsSlice() []byte {
	return s.inner
}

func NodeVecDefault() NodeVec {
	return *NodeVecFromSliceUnchecked([]byte{4, 0, 0, 0})
}

func NodeVecFromSlice(slice []byte, compatible bool) (*NodeVec, error) {
	sliceLen := len(slice)

	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "NodeVec", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "NodeVec", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint {
		return &NodeVec{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "NodeVec", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if offsetFirst%4 != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "NodeVec", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	itemCount := offsetFirst/4 - 1
	headerSize := HeaderSizeUint * (uint32(itemCount) + 1)
	if uint32(sliceLen) < headerSize {
		errMsg := strings.Join([]string{"HeaderIsBroken", "NodeVec", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(headerSize))}, " ")
		return nil, errors.New(errMsg)
	}

	offsets := make([]uint32, itemCount)

	for i := 0; i < int(itemCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][4*i:]))
	}

	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			errMsg := strings.Join([]string{"OffsetsNotMatch", "NodeVec"}, " ")
			return nil, errors.New(errMsg)
		}
	}

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 {
			start := offsets[i-1]
			end := offsets[i]
			_, err := NodeFromSlice(slice[start:end], compatible)

			if err != nil {
				return nil, err
			}
		}
	}

	return &NodeVec{inner: slice}, nil
}

func (s *NodeVec) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *NodeVec) ItemCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *NodeVec) Len() uint {
	return s.ItemCount()
}
func (s *NodeVec) IsEmpty() bool {
	return s.Len() == 0
}

// if *Node is nil, index is out of bounds
func (s *NodeVec) Get(index uint) *Node {
	var b *Node
	if index < s.Len() {
		start_index := uint(HeaderSizeUint) * (1 + index)
		start := unpackNumber(s.inner[start_index:])

		if index == s.Len()-1 {
			b = NodeFromSliceUnchecked(s.inner[start:])
		} else {
			end_index := start_index + uint(HeaderSizeUint)
			end := unpackNumber(s.inner[end_index:])
			b = NodeFromSliceUnchecked(s.inner[start:end])
		}
	}
	return b
}

func (s *NodeVec) AsBuilder() NodeVecBuilder {
	size := s.ItemCount()
	t := NewNodeVecBuilder()
	for i := uint(0); i < size; i++ {
		t.Push(*s.Get(i))
	}
	return *t
}

type Uint32Builder struct {
	inner [4]Byte
}

func NewUint32Builder() *Uint32Builder {
	return &Uint32Builder{inner: [4]Byte{ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault()}}
}

func (s *Uint32Builder) Build() Uint32 {
	b := new(bytes.Buffer)
	len := len(s.inner)
	for i := 0; i < len; i++ {
		b.Write(s.inner[i].AsSlice())
	}
	return Uint32{inner: b.Bytes()}
}

func (s *Uint32Builder) Set(v [4]Byte) *Uint32Builder {
	s.inner = v
	return s
}

func (s *Uint32Builder) Nth0(v Byte) *Uint32Builder {
	s.inner[0] = v
	return s
}

func (s *Uint32Builder) Nth1(v Byte) *Uint32Builder {
	s.inner[1] = v
	return s
}

func (s *Uint32Builder) Nth2(v Byte) *Uint32Builder {
	s.inner[2] = v
	return s
}

func (s *Uint32Builder) Nth3(v Byte) *Uint32Builder {
	s.inner[3] = v
	return s
}

type Uint32 struct {
	inner []byte
}

func Uint32FromSliceUnchecked(slice []byte) *Uint32 {
	return &Uint32{inner: slice}
}
func (s *Uint32) AsSlice() []byte {
	return s.inner
}

func Uint32Default() Uint32 {
	return *Uint32FromSliceUnchecked([]byte{0, 0, 0, 0})
}

func Uint32FromSlice(slice []byte, _compatible bool) (*Uint32, error) {
	sliceLen := len(slice)
	if sliceLen != 4 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "Uint32", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(4)}, " ")
		return nil, errors.New(errMsg)
	}
	return &Uint32{inner: slice}, nil
}

func (s *Uint32) RawData() []byte {
	return s.inner
}

func (s *Uint32) Nth0() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[0:1])
	return ret
}

func (s *Uint32) Nth1() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[1:2])
	return ret
}

func (s *Uint32) Nth2() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[2:3])
	return ret
}

func (s *Uint32) Nth3() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[3:4])
	return ret
}

func (s *Uint32) AsBuilder() Uint32Builder {
	t := NewUint32Builder()
	t.Nth0(*s.Nth0())
	t.Nth1(*s.Nth1())
	t.Nth2(*s.Nth2())
	t.Nth3(*s.Nth3())
	return *t
}

type Uint16Builder struct {
	inner [2]Byte
}

func NewUint16Builder() *Uint16Builder {
	return &Uint16Builder{inner: [2]Byte{ByteDefault(), ByteDefault()}}
}

func (s *Uint16Builder) Build() Uint16 {
	b := new(bytes.Buffer)
	len := len(s.inner)
	for i := 0; i < len; i++ {
		b.Write(s.inner[i].AsSlice())
	}
	return Uint16{inner: b.Bytes()}
}

func (s *Uint16Builder) Set(v [2]Byte) *Uint16Builder {
	s.inner = v
	return s
}

func (s *Uint16Builder) Nth0(v Byte) *Uint16Builder {
	s.inner[0] = v
	return s
}

func (s *Uint16Builder) Nth1(v Byte) *Uint16Builder {
	s.inner[1] = v
	return s
}

type Uint16 struct {
	inner []byte
}

func Uint16FromSliceUnchecked(slice []byte) *Uint16 {
	return &Uint16{inner: slice}
}
func (s *Uint16) AsSlice() []byte {
	return s.inner
}

func Uint16Default() Uint16 {
	return *Uint16FromSliceUnchecked([]byte{0, 0})
}

func Uint16FromSlice(slice []byte, _compatible bool) (*Uint16, error) {
	sliceLen := len(slice)
	if sliceLen != 2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "Uint16", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(2)}, " ")
		return nil, errors.New(errMsg)
	}
	return &Uint16{inner: slice}, nil
}

func (s *Uint16) RawData() []byte {
	return s.inner
}

func (s *Uint16) Nth0() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[0:1])
	return ret
}

func (s *Uint16) Nth1() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[1:2])
	return ret
}

func (s *Uint16) AsBuilder() Uint16Builder {
	t := NewUint16Builder()
	t.Nth0(*s.Nth0())
	t.Nth1(*s.Nth1())
	return *t
}

type BoolBuilder struct {
	inner [1]Byte
}

func NewBoolBuilder() *BoolBuilder {
	return &BoolBuilder{inner: [1]Byte{ByteDefault()}}
}

func (s *BoolBuilder) Build() Bool {
	b := new(bytes.Buffer)
	len := len(s.inner)
	for i := 0; i < len; i++ {
		b.Write(s.inner[i].AsSlice())
	}
	return Bool{inner: b.Bytes()}
}

func (s *BoolBuilder) Set(v [1]Byte) *BoolBuilder {
	s.inner = v
	return s
}

func (s *BoolBuilder) Nth0(v Byte) *BoolBuilder {
	s.inner[0] = v
	return s
}

type Bool struct {
	inner []byte
}

func BoolFromSliceUnchecked(slice []byte) *Bool {
	return &Bool{inner: slice}
}
func (s *Bool) AsSlice() []byte {
	return s.inner
}

func BoolDefault() Bool {
	return *BoolFromSliceUnchecked([]byte{0})
}

func BoolFromSlice(slice []byte, _compatible bool) (*Bool, error) {
	sliceLen := len(slice)
	if sliceLen != 1 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "Bool", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(1)}, " ")
		return nil, errors.New(errMsg)
	}
	return &Bool{inner: slice}, nil
}

func (s *Bool) RawData() []byte {
	return s.inner
}

func (s *Bool) Nth0() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[0:1])
	return ret
}

func (s *Bool) AsBuilder() BoolBuilder {
	t := NewBoolBuilder()
	t.Nth0(*s.Nth0())
	return *t
}

type PortOptBuilder struct {
	isNone bool
	inner  Uint16
}

func NewPortOptBuilder() *PortOptBuilder {
	return &PortOptBuilder{isNone: true, inner: Uint16Default()}
}
func (s *PortOptBuilder) Set(v Uint16) *PortOptBuilder {
	s.isNone = false
	s.inner = v
	return s
}
func (s *PortOptBuilder) Build() PortOpt {
	var ret PortOpt
	if s.isNone {
		ret = PortOpt{inner: []byte{}}
	} else {
		ret = PortOpt{inner: s.inner.AsSlice()}
	}
	return ret
}

type PortOpt struct {
	inner []byte
}

func PortOptFromSliceUnchecked(slice []byte) *PortOpt {
	return &PortOpt{inner: slice}
}
func (s *PortOpt) AsSlice() []byte {
	return s.inner
}

func PortOptDefault() PortOpt {
	return *PortOptFromSliceUnchecked([]byte{})
}

func PortOptFromSlice(slice []byte, compatible bool) (*PortOpt, error) {
	if len(slice) == 0 {
		return &PortOpt{inner: slice}, nil
	}

	_, err := Uint16FromSlice(slice, compatible)
	if err != nil {
		return nil, err
	}
	return &PortOpt{inner: slice}, nil
}

func (s *PortOpt) IntoUint16() (*Uint16, error) {
	if s.IsNone() {
		return nil, errors.New("No data")
	}
	return Uint16FromSliceUnchecked(s.AsSlice()), nil
}
func (s *PortOpt) IsSome() bool {
	return len(s.inner) != 0
}
func (s *PortOpt) IsNone() bool {
	return len(s.inner) == 0
}
func (s *PortOpt) AsBuilder() PortOptBuilder {
	var ret = NewPortOptBuilder()
	if s.IsSome() {
		ret.Set(*Uint16FromSliceUnchecked(s.AsSlice()))
	}
	return *ret
}

type DiscoveryPayloadBuilder struct {
	inner DiscoveryPayloadUnion
}

func NewDiscoveryPayloadBuilder() *DiscoveryPayloadBuilder {
	v := DiscoveryPayloadDefault()
	return &DiscoveryPayloadBuilder{inner: *v.ToUnion()}
}
func (s *DiscoveryPayloadBuilder) Set(v DiscoveryPayloadUnion) *DiscoveryPayloadBuilder {
	s.inner = v
	return s
}
func (s *DiscoveryPayloadBuilder) Build() DiscoveryPayload {
	b := new(bytes.Buffer)
	b.Write(packNumber(s.inner.itemID))
	b.Write(s.inner.AsSlice())

	return DiscoveryPayload{inner: b.Bytes()}
}

type DiscoveryPayload struct {
	inner []byte
}

func DiscoveryPayloadFromSliceUnchecked(slice []byte) *DiscoveryPayload {
	return &DiscoveryPayload{inner: slice}
}
func (s *DiscoveryPayload) AsSlice() []byte {
	return s.inner
}

func DiscoveryPayloadDefault() DiscoveryPayload {
	return *DiscoveryPayloadFromSliceUnchecked([]byte{0, 0, 0, 0, 24, 0, 0, 0, 16, 0, 0, 0, 20, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

type DiscoveryPayloadUnion struct {
	itemID Number
	inner  []byte
}

func (s *DiscoveryPayloadUnion) AsSlice() []byte {
	return s.inner
}
func (s *DiscoveryPayloadUnion) ItemID() Number {
	return s.itemID
}

func DiscoveryPayloadUnionFromGetNodes(v GetNodes) DiscoveryPayloadUnion {
	return DiscoveryPayloadUnion{itemID: 0, inner: v.AsSlice()}
}

func (s *DiscoveryPayloadUnion) IntoGetNodes() *GetNodes {
	switch s.ItemID() {
	case 0:
		return GetNodesFromSliceUnchecked(s.AsSlice())
	default:
		errMsg := strings.Join([]string{"invalid item_id: expect 0, found", strconv.Itoa(int(s.ItemID()))}, " ")
		panic(errMsg)
	}
}

func DiscoveryPayloadUnionFromNodes(v Nodes) DiscoveryPayloadUnion {
	return DiscoveryPayloadUnion{itemID: 1, inner: v.AsSlice()}
}

func (s *DiscoveryPayloadUnion) IntoNodes() *Nodes {
	switch s.ItemID() {
	case 1:
		return NodesFromSliceUnchecked(s.AsSlice())
	default:
		errMsg := strings.Join([]string{"invalid item_id: expect 1, found", strconv.Itoa(int(s.ItemID()))}, " ")
		panic(errMsg)
	}
}

func (s *DiscoveryPayloadUnion) ItemName() string {
	switch s.itemID {

	case 0:
		return "GetNodes"

	case 1:
		return "Nodes"

	default:
		panic("invalid data: DiscoveryPayloadUnion")
	}
}

func (s *DiscoveryPayload) ToUnion() *DiscoveryPayloadUnion {
	switch s.ItemID() {

	case 0:
		return &DiscoveryPayloadUnion{itemID: 0, inner: s.inner[HeaderSizeUint:]}

	case 1:
		return &DiscoveryPayloadUnion{itemID: 1, inner: s.inner[HeaderSizeUint:]}

	default:
		panic("invalid data: DiscoveryPayload")
	}
}

func DiscoveryPayloadFromSlice(slice []byte, compatible bool) (*DiscoveryPayload, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "DiscoveryPayload", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}
	itemID := unpackNumber(slice)
	innerSlice := slice[HeaderSizeUint:]

	switch itemID {

	case 0:
		_, err := GetNodesFromSlice(innerSlice, compatible)
		if err != nil {
			return nil, err
		}

	case 1:
		_, err := NodesFromSlice(innerSlice, compatible)
		if err != nil {
			return nil, err
		}

	default:
		return nil, errors.New("UnknownItem, DiscoveryPayload")
	}
	return &DiscoveryPayload{inner: slice}, nil
}

func (s *DiscoveryPayload) ItemID() Number {
	return unpackNumber(s.inner)
}
func (s *DiscoveryPayload) AsBuilder() DiscoveryPayloadBuilder {
	return *NewDiscoveryPayloadBuilder().Set(*s.ToUnion())
}

type DiscoveryMessageBuilder struct {
	payload DiscoveryPayload
}

func (s *DiscoveryMessageBuilder) Build() DiscoveryMessage {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (1 + 1)
	offsets := make([]uint32, 0, 1)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.payload.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.payload.AsSlice())
	return DiscoveryMessage{inner: b.Bytes()}
}

func (s *DiscoveryMessageBuilder) Payload(v DiscoveryPayload) *DiscoveryMessageBuilder {
	s.payload = v
	return s
}

func NewDiscoveryMessageBuilder() *DiscoveryMessageBuilder {
	return &DiscoveryMessageBuilder{payload: DiscoveryPayloadDefault()}
}

type DiscoveryMessage struct {
	inner []byte
}

func DiscoveryMessageFromSliceUnchecked(slice []byte) *DiscoveryMessage {
	return &DiscoveryMessage{inner: slice}
}
func (s *DiscoveryMessage) AsSlice() []byte {
	return s.inner
}

func DiscoveryMessageDefault() DiscoveryMessage {
	return *DiscoveryMessageFromSliceUnchecked([]byte{36, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 16, 0, 0, 0, 20, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func DiscoveryMessageFromSlice(slice []byte, compatible bool) (*DiscoveryMessage, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "DiscoveryMessage", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "DiscoveryMessage", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint && 1 == 0 {
		return &DiscoveryMessage{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "DiscoveryMessage", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if offsetFirst%4 != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "DiscoveryMessage", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := offsetFirst/4 - 1
	if fieldCount < 1 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 1 {
		return nil, errors.New("FieldCountNotMatch")
	}

	headerSize := HeaderSizeUint * (uint32(fieldCount) + 1)
	if uint32(sliceLen) < headerSize {
		errMsg := strings.Join([]string{"HeaderIsBroken", "DiscoveryMessage", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(headerSize))}, " ")
		return nil, errors.New(errMsg)
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = DiscoveryPayloadFromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	return &DiscoveryMessage{inner: slice}, nil
}

func (s *DiscoveryMessage) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *DiscoveryMessage) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *DiscoveryMessage) Len() uint {
	return s.FieldCount()
}
func (s *DiscoveryMessage) IsEmpty() bool {
	return s.Len() == 0
}
func (s *DiscoveryMessage) CountExtraFields() uint {
	return s.FieldCount() - 1
}

func (s *DiscoveryMessage) HasExtraFields() bool {
	return 1 != s.FieldCount()
}

func (s *DiscoveryMessage) Payload() *DiscoveryPayload {
	var ret *DiscoveryPayload
	start := unpackNumber(s.inner[4:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[8:])
		ret = DiscoveryPayloadFromSliceUnchecked(s.inner[start:end])
	} else {
		ret = DiscoveryPayloadFromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *DiscoveryMessage) AsBuilder() DiscoveryMessageBuilder {
	ret := NewDiscoveryMessageBuilder().Payload(*s.Payload())
	return *ret
}

type GetNodesBuilder struct {
	version     Uint32
	count       Uint32
	listen_port PortOpt
}

func (s *GetNodesBuilder) Build() GetNodes {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (3 + 1)
	offsets := make([]uint32, 0, 3)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.version.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.count.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.listen_port.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.version.AsSlice())
	b.Write(s.count.AsSlice())
	b.Write(s.listen_port.AsSlice())
	return GetNodes{inner: b.Bytes()}
}

func (s *GetNodesBuilder) Version(v Uint32) *GetNodesBuilder {
	s.version = v
	return s
}

func (s *GetNodesBuilder) Count(v Uint32) *GetNodesBuilder {
	s.count = v
	return s
}

func (s *GetNodesBuilder) ListenPort(v PortOpt) *GetNodesBuilder {
	s.listen_port = v
	return s
}

func NewGetNodesBuilder() *GetNodesBuilder {
	return &GetNodesBuilder{version: Uint32Default(), count: Uint32Default(), listen_port: PortOptDefault()}
}

type GetNodes struct {
	inner []byte
}

func GetNodesFromSliceUnchecked(slice []byte) *GetNodes {
	return &GetNodes{inner: slice}
}
func (s *GetNodes) AsSlice() []byte {
	return s.inner
}

func GetNodesDefault() GetNodes {
	return *GetNodesFromSliceUnchecked([]byte{24, 0, 0, 0, 16, 0, 0, 0, 20, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func GetNodesFromSlice(slice []byte, compatible bool) (*GetNodes, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "GetNodes", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "GetNodes", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint && 3 == 0 {
		return &GetNodes{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "GetNodes", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if offsetFirst%4 != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "GetNodes", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := offsetFirst/4 - 1
	if fieldCount < 3 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 3 {
		return nil, errors.New("FieldCountNotMatch")
	}

	headerSize := HeaderSizeUint * (uint32(fieldCount) + 1)
	if uint32(sliceLen) < headerSize {
		errMsg := strings.Join([]string{"HeaderIsBroken", "GetNodes", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(headerSize))}, " ")
		return nil, errors.New(errMsg)
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = Uint32FromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint32FromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = PortOptFromSlice(slice[offsets[2]:offsets[3]], compatible)
	if err != nil {
		return nil, err
	}

	return &GetNodes{inner: slice}, nil
}

func (s *GetNodes) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *GetNodes) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *GetNodes) Len() uint {
	return s.FieldCount()
}
func (s *GetNodes) IsEmpty() bool {
	return s.Len() == 0
}
func (s *GetNodes) CountExtraFields() uint {
	return s.FieldCount() - 3
}

func (s *GetNodes) HasExtraFields() bool {
	return 3 != s.FieldCount()
}

func (s *GetNodes) Version() *Uint32 {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return Uint32FromSliceUnchecked(s.inner[start:end])
}

func (s *GetNodes) Count() *Uint32 {
	start := unpackNumber(s.inner[8:])
	end := unpackNumber(s.inner[12:])
	return Uint32FromSliceUnchecked(s.inner[start:end])
}

func (s *GetNodes) ListenPort() *PortOpt {
	var ret *PortOpt
	start := unpackNumber(s.inner[12:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[16:])
		ret = PortOptFromSliceUnchecked(s.inner[start:end])
	} else {
		ret = PortOptFromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *GetNodes) AsBuilder() GetNodesBuilder {
	ret := NewGetNodesBuilder().Version(*s.Version()).Count(*s.Count()).ListenPort(*s.ListenPort())
	return *ret
}

type NodesBuilder struct {
	announce Bool
	items    NodeVec
}

func (s *NodesBuilder) Build() Nodes {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (2 + 1)
	offsets := make([]uint32, 0, 2)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.announce.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.items.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.announce.AsSlice())
	b.Write(s.items.AsSlice())
	return Nodes{inner: b.Bytes()}
}

func (s *NodesBuilder) Announce(v Bool) *NodesBuilder {
	s.announce = v
	return s
}

func (s *NodesBuilder) Items(v NodeVec) *NodesBuilder {
	s.items = v
	return s
}

func NewNodesBuilder() *NodesBuilder {
	return &NodesBuilder{announce: BoolDefault(), items: NodeVecDefault()}
}

type Nodes struct {
	inner []byte
}

func NodesFromSliceUnchecked(slice []byte) *Nodes {
	return &Nodes{inner: slice}
}
func (s *Nodes) AsSlice() []byte {
	return s.inner
}

func NodesDefault() Nodes {
	return *NodesFromSliceUnchecked([]byte{17, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 0, 4, 0, 0, 0})
}

func NodesFromSlice(slice []byte, compatible bool) (*Nodes, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "Nodes", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "Nodes", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint && 2 == 0 {
		return &Nodes{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "Nodes", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if offsetFirst%4 != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "Nodes", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := offsetFirst/4 - 1
	if fieldCount < 2 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 2 {
		return nil, errors.New("FieldCountNotMatch")
	}

	headerSize := HeaderSizeUint * (uint32(fieldCount) + 1)
	if uint32(sliceLen) < headerSize {
		errMsg := strings.Join([]string{"HeaderIsBroken", "Nodes", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(headerSize))}, " ")
		return nil, errors.New(errMsg)
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = BoolFromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = NodeVecFromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	return &Nodes{inner: slice}, nil
}

func (s *Nodes) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *Nodes) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *Nodes) Len() uint {
	return s.FieldCount()
}
func (s *Nodes) IsEmpty() bool {
	return s.Len() == 0
}
func (s *Nodes) CountExtraFields() uint {
	return s.FieldCount() - 2
}

func (s *Nodes) HasExtraFields() bool {
	return 2 != s.FieldCount()
}

func (s *Nodes) Announce() *Bool {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return BoolFromSliceUnchecked(s.inner[start:end])
}

func (s *Nodes) Items() *NodeVec {
	var ret *NodeVec
	start := unpackNumber(s.inner[8:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[12:])
		ret = NodeVecFromSliceUnchecked(s.inner[start:end])
	} else {
		ret = NodeVecFromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *Nodes) AsBuilder() NodesBuilder {
	ret := NewNodesBuilder().Announce(*s.Announce()).Items(*s.Items())
	return *ret
}

type NodeBuilder struct {
	addresses BytesVec
}

func (s *NodeBuilder) Build() Node {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (1 + 1)
	offsets := make([]uint32, 0, 1)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.addresses.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.addresses.AsSlice())
	return Node{inner: b.Bytes()}
}

func (s *NodeBuilder) Addresses(v BytesVec) *NodeBuilder {
	s.addresses = v
	return s
}

func NewNodeBuilder() *NodeBuilder {
	return &NodeBuilder{addresses: BytesVecDefault()}
}

type Node struct {
	inner []byte
}

func NodeFromSliceUnchecked(slice []byte) *Node {
	return &Node{inner: slice}
}
func (s *Node) AsSlice() []byte {
	return s.inner
}

func NodeDefault() Node {
	return *NodeFromSliceUnchecked([]byte{12, 0, 0, 0, 8, 0, 0, 0, 4, 0, 0, 0})
}

func NodeFromSlice(slice []byte, compatible bool) (*Node, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "Node", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "Node", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint && 1 == 0 {
		return &Node{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "Node", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if offsetFirst%4 != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "Node", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := offsetFirst/4 - 1
	if fieldCount < 1 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 1 {
		return nil, errors.New("FieldCountNotMatch")
	}

	headerSize := HeaderSizeUint * (uint32(fieldCount) + 1)
	if uint32(sliceLen) < headerSize {
		errMsg := strings.Join([]string{"HeaderIsBroken", "Node", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(headerSize))}, " ")
		return nil, errors.New(errMsg)
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = BytesVecFromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	return &Node{inner: slice}, nil
}

func (s *Node) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *Node) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *Node) Len() uint {
	return s.FieldCount()
}
func (s *Node) IsEmpty() bool {
	return s.Len() == 0
}
func (s *Node) CountExtraFields() uint {
	return s.FieldCount() - 1
}

func (s *Node) HasExtraFields() bool {
	return 1 != s.FieldCount()
}

func (s *Node) Addresses() *BytesVec {
	var ret *BytesVec
	start := unpackNumber(s.inner[4:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[8:])
		ret = BytesVecFromSliceUnchecked(s.inner[start:end])
	} else {
		ret = BytesVecFromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *Node) AsBuilder() NodeBuilder {
	ret := NewNodeBuilder().Addresses(*s.Addresses())
	return *ret
}
