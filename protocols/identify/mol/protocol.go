// Generated by Molecule 0.6.0

package protocol

import (
	"bytes"
	"encoding/binary"
	"errors"
	"strconv"
	"strings"
)

type Number uint32

const HeaderSizeUint uint32 = 4

// Byte is the primitive type
type Byte [1]byte

func NewByte(b byte) Byte {
	return Byte([1]byte{b})
}
func ByteDefault() Byte {
	return Byte([1]byte{0})
}
func ByteFromSliceUnchecked(slice []byte) *Byte {
	b := new(Byte)
	b[0] = slice[0]
	return b
}
func (b *Byte) AsSlice() []byte {
	return b[:]
}
func ByteFromSlice(slice []byte, _compatible bool) (*Byte, error) {
	if len(slice) != 1 {
		return nil, errors.New("TotalSizeNotMatch")
	}
	b := new(Byte)
	b[0] = slice[0]
	return b, nil
}
func unpackNumber(b []byte) Number {
	bytesBuffer := bytes.NewBuffer(b)
	var x Number
	binary.Read(bytesBuffer, binary.LittleEndian, &x)
	return x
}
func packNumber(num Number) []byte {
	b := make([]byte, 4)
	binary.LittleEndian.PutUint32(b, uint32(num))
	return b
}

type BytesBuilder struct {
	inner []Byte
}

func (s *BytesBuilder) Build() Bytes {
	size := packNumber(Number(len(s.inner)))

	b := new(bytes.Buffer)

	b.Write(size)
	len := len(s.inner)
	for i := 0; i < len; i++ {
		b.Write(s.inner[i].AsSlice())
	}

	sb := Bytes{inner: b.Bytes()}

	return sb
}

func (s *BytesBuilder) Set(v []Byte) *BytesBuilder {
	s.inner = v
	return s
}
func (s *BytesBuilder) Push(v Byte) *BytesBuilder {
	s.inner = append(s.inner, v)
	return s
}
func (s *BytesBuilder) Extend(iter []Byte) *BytesBuilder {
	for i := 0; i < len(iter); i++ {
		s.inner = append(s.inner, iter[i])
	}
	return s
}

func NewBytesBuilder() *BytesBuilder {
	return &BytesBuilder{[]Byte{}}
}

type Bytes struct {
	inner []byte
}

func BytesFromSliceUnchecked(slice []byte) *Bytes {
	return &Bytes{inner: slice}
}
func (s *Bytes) AsSlice() []byte {
	return s.inner
}

func BytesDefault() Bytes {
	return *BytesFromSliceUnchecked([]byte{0, 0, 0, 0})
}

func BytesFromSlice(slice []byte, _compatible bool) (*Bytes, error) {
	sliceLen := len(slice)
	if sliceLen < int(HeaderSizeUint) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "Bytes", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}
	itemCount := unpackNumber(slice)
	if itemCount == 0 {
		if sliceLen != int(HeaderSizeUint) {
			errMsg := strings.Join([]string{"TotalSizeNotMatch", "Bytes", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(HeaderSizeUint))}, " ")
			return nil, errors.New(errMsg)
		}
		return &Bytes{inner: slice}, nil
	}
	totalSize := int(HeaderSizeUint) + int(1*itemCount)
	if sliceLen != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "Bytes", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}
	return &Bytes{inner: slice}, nil
}

func (s *Bytes) TotalSize() uint {
	return uint(HeaderSizeUint) * (s.ItemCount() + 1)
}
func (s *Bytes) ItemCount() uint {
	number := uint(unpackNumber(s.inner))
	return number
}
func (s *Bytes) Len() uint {
	return s.ItemCount()
}
func (s *Bytes) IsEmpty() bool {
	return s.Len() == 0
}

// if *Byte is nil, index is out of bounds
func (s *Bytes) Get(index uint) *Byte {
	var re *Byte
	if index < s.Len() {
		start := uint(HeaderSizeUint) + 1*index
		end := start + 1
		re = ByteFromSliceUnchecked(s.inner[start:end])
	}
	return re
}

func (s *Bytes) RawData() []byte {
	return s.inner[HeaderSizeUint:]
}

func (s *Bytes) AsBuilder() BytesBuilder {
	size := s.ItemCount()
	t := NewBytesBuilder()
	for i := uint(0); i < size; i++ {
		t.Push(*s.Get(i))
	}
	return *t
}

type AddressVecBuilder struct {
	inner []Address
}

func (s *AddressVecBuilder) Build() AddressVec {
	itemCount := len(s.inner)
	size := packNumber(Number(itemCount))

	b := new(bytes.Buffer)

	// Empty dyn vector, just return size's bytes
	if itemCount == 0 {
		b.Write(size)
		return AddressVec{inner: b.Bytes()}
	}

	// Calculate first offset then loop for rest items offsets
	totalSize := HeaderSizeUint * uint32(itemCount+1)
	offsets := make([]uint32, 0, itemCount)
	offsets = append(offsets, totalSize)
	for i := 1; i < itemCount; i++ {
		totalSize += uint32(len(s.inner[i-1].AsSlice()))
		offsets = append(offsets, offsets[i-1]+uint32(len(s.inner[i-1].AsSlice())))
	}
	totalSize += uint32(len(s.inner[itemCount-1].AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < itemCount; i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	for i := 0; i < itemCount; i++ {
		b.Write(s.inner[i].AsSlice())
	}

	return AddressVec{inner: b.Bytes()}
}

func (s *AddressVecBuilder) Set(v []Address) *AddressVecBuilder {
	s.inner = v
	return s
}
func (s *AddressVecBuilder) Push(v Address) *AddressVecBuilder {
	s.inner = append(s.inner, v)
	return s
}
func (s *AddressVecBuilder) Extend(iter []Address) *AddressVecBuilder {
	for i := 0; i < len(iter); i++ {
		s.inner = append(s.inner, iter[i])
	}
	return s
}

func NewAddressVecBuilder() *AddressVecBuilder {
	return &AddressVecBuilder{[]Address{}}
}

type AddressVec struct {
	inner []byte
}

func AddressVecFromSliceUnchecked(slice []byte) *AddressVec {
	return &AddressVec{inner: slice}
}
func (s *AddressVec) AsSlice() []byte {
	return s.inner
}

func AddressVecDefault() AddressVec {
	return *AddressVecFromSliceUnchecked([]byte{4, 0, 0, 0})
}

func AddressVecFromSlice(slice []byte, compatible bool) (*AddressVec, error) {
	sliceLen := len(slice)

	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "AddressVec", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "AddressVec", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint {
		return &AddressVec{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "AddressVec", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if offsetFirst%4 != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "AddressVec", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	itemCount := offsetFirst/4 - 1
	headerSize := HeaderSizeUint * (uint32(itemCount) + 1)
	if uint32(sliceLen) < headerSize {
		errMsg := strings.Join([]string{"HeaderIsBroken", "AddressVec", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(headerSize))}, " ")
		return nil, errors.New(errMsg)
	}

	offsets := make([]uint32, itemCount)

	for i := 0; i < int(itemCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][4*i:]))
	}

	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			errMsg := strings.Join([]string{"OffsetsNotMatch", "AddressVec"}, " ")
			return nil, errors.New(errMsg)
		}
	}

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 {
			start := offsets[i-1]
			end := offsets[i]
			_, err := AddressFromSlice(slice[start:end], compatible)

			if err != nil {
				return nil, err
			}
		}
	}

	return &AddressVec{inner: slice}, nil
}

func (s *AddressVec) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *AddressVec) ItemCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *AddressVec) Len() uint {
	return s.ItemCount()
}
func (s *AddressVec) IsEmpty() bool {
	return s.Len() == 0
}

// if *Address is nil, index is out of bounds
func (s *AddressVec) Get(index uint) *Address {
	var b *Address
	if index < s.Len() {
		start_index := uint(HeaderSizeUint) * (1 + index)
		start := unpackNumber(s.inner[start_index:])

		if index == s.Len()-1 {
			b = AddressFromSliceUnchecked(s.inner[start:])
		} else {
			end_index := start_index + uint(HeaderSizeUint)
			end := unpackNumber(s.inner[end_index:])
			b = AddressFromSliceUnchecked(s.inner[start:end])
		}
	}
	return b
}

func (s *AddressVec) AsBuilder() AddressVecBuilder {
	size := s.ItemCount()
	t := NewAddressVecBuilder()
	for i := uint(0); i < size; i++ {
		t.Push(*s.Get(i))
	}
	return *t
}

type AddressBuilder struct {
	bytes Bytes
}

func (s *AddressBuilder) Build() Address {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (1 + 1)
	offsets := make([]uint32, 0, 1)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.bytes.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.bytes.AsSlice())
	return Address{inner: b.Bytes()}
}

func (s *AddressBuilder) Bytes(v Bytes) *AddressBuilder {
	s.bytes = v
	return s
}

func NewAddressBuilder() *AddressBuilder {
	return &AddressBuilder{bytes: BytesDefault()}
}

type Address struct {
	inner []byte
}

func AddressFromSliceUnchecked(slice []byte) *Address {
	return &Address{inner: slice}
}
func (s *Address) AsSlice() []byte {
	return s.inner
}

func AddressDefault() Address {
	return *AddressFromSliceUnchecked([]byte{12, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0})
}

func AddressFromSlice(slice []byte, compatible bool) (*Address, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "Address", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "Address", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint && 1 == 0 {
		return &Address{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "Address", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if offsetFirst%4 != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "Address", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := offsetFirst/4 - 1
	if fieldCount < 1 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 1 {
		return nil, errors.New("FieldCountNotMatch")
	}

	headerSize := HeaderSizeUint * (uint32(fieldCount) + 1)
	if uint32(sliceLen) < headerSize {
		errMsg := strings.Join([]string{"HeaderIsBroken", "Address", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(headerSize))}, " ")
		return nil, errors.New(errMsg)
	}

	offsets := make([]uint32, 1)

	for i := 0; i < 1; i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][4*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = BytesFromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	return &Address{inner: slice}, nil
}

func (s *Address) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *Address) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *Address) Len() uint {
	return s.FieldCount()
}
func (s *Address) IsEmpty() bool {
	return s.Len() == 0
}
func (s *Address) CountExtraFields() uint {
	return s.FieldCount() - 1
}

func (s *Address) hasExtraFields() bool {
	return 1 != s.FieldCount()
}

func (s *Address) Bytes() *Bytes {
	var ret *Bytes
	start := unpackNumber(s.inner[4:])
	if s.hasExtraFields() {
		end := unpackNumber(s.inner[8:])
		ret = BytesFromSliceUnchecked(s.inner[start:end])
	} else {
		ret = BytesFromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *Address) AsBuilder() AddressBuilder {
	ret := NewAddressBuilder().Bytes(*s.Bytes())
	return *ret
}

type IdentifyMessageBuilder struct {
	listen_addrs  AddressVec
	observed_addr Address
	identify      Bytes
}

func (s *IdentifyMessageBuilder) Build() IdentifyMessage {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (3 + 1)
	offsets := make([]uint32, 0, 3)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.listen_addrs.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.observed_addr.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.identify.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.listen_addrs.AsSlice())
	b.Write(s.observed_addr.AsSlice())
	b.Write(s.identify.AsSlice())
	return IdentifyMessage{inner: b.Bytes()}
}

func (s *IdentifyMessageBuilder) ListenAddrs(v AddressVec) *IdentifyMessageBuilder {
	s.listen_addrs = v
	return s
}

func (s *IdentifyMessageBuilder) ObservedAddr(v Address) *IdentifyMessageBuilder {
	s.observed_addr = v
	return s
}

func (s *IdentifyMessageBuilder) Identify(v Bytes) *IdentifyMessageBuilder {
	s.identify = v
	return s
}

func NewIdentifyMessageBuilder() *IdentifyMessageBuilder {
	return &IdentifyMessageBuilder{listen_addrs: AddressVecDefault(), observed_addr: AddressDefault(), identify: BytesDefault()}
}

type IdentifyMessage struct {
	inner []byte
}

func IdentifyMessageFromSliceUnchecked(slice []byte) *IdentifyMessage {
	return &IdentifyMessage{inner: slice}
}
func (s *IdentifyMessage) AsSlice() []byte {
	return s.inner
}

func IdentifyMessageDefault() IdentifyMessage {
	return *IdentifyMessageFromSliceUnchecked([]byte{36, 0, 0, 0, 16, 0, 0, 0, 20, 0, 0, 0, 32, 0, 0, 0, 4, 0, 0, 0, 12, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func IdentifyMessageFromSlice(slice []byte, compatible bool) (*IdentifyMessage, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "IdentifyMessage", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "IdentifyMessage", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint && 3 == 0 {
		return &IdentifyMessage{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "IdentifyMessage", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if offsetFirst%4 != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "IdentifyMessage", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := offsetFirst/4 - 1
	if fieldCount < 3 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 3 {
		return nil, errors.New("FieldCountNotMatch")
	}

	headerSize := HeaderSizeUint * (uint32(fieldCount) + 1)
	if uint32(sliceLen) < headerSize {
		errMsg := strings.Join([]string{"HeaderIsBroken", "IdentifyMessage", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(headerSize))}, " ")
		return nil, errors.New(errMsg)
	}

	offsets := make([]uint32, 3)

	for i := 0; i < 3; i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][4*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = AddressVecFromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = AddressFromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BytesFromSlice(slice[offsets[2]:offsets[3]], compatible)
	if err != nil {
		return nil, err
	}

	return &IdentifyMessage{inner: slice}, nil
}

func (s *IdentifyMessage) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *IdentifyMessage) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *IdentifyMessage) Len() uint {
	return s.FieldCount()
}
func (s *IdentifyMessage) IsEmpty() bool {
	return s.Len() == 0
}
func (s *IdentifyMessage) CountExtraFields() uint {
	return s.FieldCount() - 3
}

func (s *IdentifyMessage) hasExtraFields() bool {
	return 3 != s.FieldCount()
}

func (s *IdentifyMessage) ListenAddrs() *AddressVec {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return AddressVecFromSliceUnchecked(s.inner[start:end])
}

func (s *IdentifyMessage) ObservedAddr() *Address {
	start := unpackNumber(s.inner[8:])
	end := unpackNumber(s.inner[12:])
	return AddressFromSliceUnchecked(s.inner[start:end])
}

func (s *IdentifyMessage) Identify() *Bytes {
	var ret *Bytes
	start := unpackNumber(s.inner[12:])
	if s.hasExtraFields() {
		end := unpackNumber(s.inner[16:])
		ret = BytesFromSliceUnchecked(s.inner[start:end])
	} else {
		ret = BytesFromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *IdentifyMessage) AsBuilder() IdentifyMessageBuilder {
	ret := NewIdentifyMessageBuilder().ListenAddrs(*s.ListenAddrs()).ObservedAddr(*s.ObservedAddr()).Identify(*s.Identify())
	return *ret
}
