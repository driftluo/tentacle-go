// Generated by Molecule 0.8.0
// Generated by Moleculec-Go 0.1.11

package protocol

import (
	"bytes"
	"encoding/binary"
	"errors"
	"strconv"
	"strings"
)

type Number uint32

const HeaderSizeUint uint32 = 4

// Byte is the primitive type
type Byte [1]byte

func NewByte(b byte) Byte {
	return Byte([1]byte{b})
}
func ByteDefault() Byte {
	return Byte([1]byte{0})
}
func ByteFromSliceUnchecked(slice []byte) *Byte {
	b := new(Byte)
	b[0] = slice[0]
	return b
}
func (b *Byte) AsSlice() []byte {
	return b[:]
}
func ByteFromSlice(slice []byte, _compatible bool) (*Byte, error) {
	if len(slice) != 1 {
		return nil, errors.New("TotalSizeNotMatch")
	}
	b := new(Byte)
	b[0] = slice[0]
	return b, nil
}
func unpackNumber(b []byte) Number {
	bytesBuffer := bytes.NewBuffer(b)
	var x Number
	binary.Read(bytesBuffer, binary.LittleEndian, &x)
	return x
}
func packNumber(num Number) []byte {
	b := make([]byte, 4)
	binary.LittleEndian.PutUint32(b, uint32(num))
	return b
}

type Uint32Builder struct {
	inner [4]Byte
}

func NewUint32Builder() *Uint32Builder {
	return &Uint32Builder{inner: [4]Byte{ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault()}}
}

func (s *Uint32Builder) Build() Uint32 {
	b := new(bytes.Buffer)
	len := len(s.inner)
	for i := 0; i < len; i++ {
		b.Write(s.inner[i].AsSlice())
	}
	return Uint32{inner: b.Bytes()}
}

func (s *Uint32Builder) Set(v [4]Byte) *Uint32Builder {
	s.inner = v
	return s
}

func (s *Uint32Builder) Nth0(v Byte) *Uint32Builder {
	s.inner[0] = v
	return s
}

func (s *Uint32Builder) Nth1(v Byte) *Uint32Builder {
	s.inner[1] = v
	return s
}

func (s *Uint32Builder) Nth2(v Byte) *Uint32Builder {
	s.inner[2] = v
	return s
}

func (s *Uint32Builder) Nth3(v Byte) *Uint32Builder {
	s.inner[3] = v
	return s
}

type Uint32 struct {
	inner []byte
}

func Uint32FromSliceUnchecked(slice []byte) *Uint32 {
	return &Uint32{inner: slice}
}
func (s *Uint32) AsSlice() []byte {
	return s.inner
}

func Uint32Default() Uint32 {
	return *Uint32FromSliceUnchecked([]byte{0, 0, 0, 0})
}

func Uint32FromSlice(slice []byte, _compatible bool) (*Uint32, error) {
	sliceLen := len(slice)
	if sliceLen != 4 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "Uint32", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(4)}, " ")
		return nil, errors.New(errMsg)
	}
	return &Uint32{inner: slice}, nil
}

func (s *Uint32) RawData() []byte {
	return s.inner
}

func (s *Uint32) Nth0() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[0:1])
	return ret
}

func (s *Uint32) Nth1() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[1:2])
	return ret
}

func (s *Uint32) Nth2() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[2:3])
	return ret
}

func (s *Uint32) Nth3() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[3:4])
	return ret
}

func (s *Uint32) AsBuilder() Uint32Builder {
	t := NewUint32Builder()
	t.Nth0(*s.Nth0())
	t.Nth1(*s.Nth1())
	t.Nth2(*s.Nth2())
	t.Nth3(*s.Nth3())
	return *t
}

type PingPayloadBuilder struct {
	inner PingPayloadUnion
}

func NewPingPayloadBuilder() *PingPayloadBuilder {
	v := PingPayloadDefault()
	return &PingPayloadBuilder{inner: *v.ToUnion()}
}
func (s *PingPayloadBuilder) Set(v PingPayloadUnion) *PingPayloadBuilder {
	s.inner = v
	return s
}
func (s *PingPayloadBuilder) Build() PingPayload {
	b := new(bytes.Buffer)
	b.Write(packNumber(s.inner.itemID))
	b.Write(s.inner.AsSlice())

	return PingPayload{inner: b.Bytes()}
}

type PingPayload struct {
	inner []byte
}

func PingPayloadFromSliceUnchecked(slice []byte) *PingPayload {
	return &PingPayload{inner: slice}
}
func (s *PingPayload) AsSlice() []byte {
	return s.inner
}

func PingPayloadDefault() PingPayload {
	return *PingPayloadFromSliceUnchecked([]byte{0, 0, 0, 0, 12, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0})
}

type PingPayloadUnion struct {
	itemID Number
	inner  []byte
}

func (s *PingPayloadUnion) AsSlice() []byte {
	return s.inner
}
func (s *PingPayloadUnion) ItemID() Number {
	return s.itemID
}

func PingPayloadUnionFromPing(v Ping) PingPayloadUnion {
	return PingPayloadUnion{itemID: 0, inner: v.AsSlice()}
}

func (s *PingPayloadUnion) IntoPing() *Ping {
	switch s.ItemID() {
	case 0:
		return PingFromSliceUnchecked(s.AsSlice())
	default:
		errMsg := strings.Join([]string{"invalid item_id: expect 0, found", strconv.Itoa(int(s.ItemID()))}, " ")
		panic(errMsg)
	}
}

func PingPayloadUnionFromPong(v Pong) PingPayloadUnion {
	return PingPayloadUnion{itemID: 1, inner: v.AsSlice()}
}

func (s *PingPayloadUnion) IntoPong() *Pong {
	switch s.ItemID() {
	case 1:
		return PongFromSliceUnchecked(s.AsSlice())
	default:
		errMsg := strings.Join([]string{"invalid item_id: expect 1, found", strconv.Itoa(int(s.ItemID()))}, " ")
		panic(errMsg)
	}
}

func (s *PingPayloadUnion) ItemName() string {
	switch s.itemID {

	case 0:
		return "Ping"

	case 1:
		return "Pong"

	default:
		panic("invalid data: PingPayloadUnion")
	}
}

func (s *PingPayload) ToUnion() *PingPayloadUnion {
	switch s.ItemID() {

	case 0:
		return &PingPayloadUnion{itemID: 0, inner: s.inner[HeaderSizeUint:]}

	case 1:
		return &PingPayloadUnion{itemID: 1, inner: s.inner[HeaderSizeUint:]}

	default:
		panic("invalid data: PingPayload")
	}
}

func PingPayloadFromSlice(slice []byte, compatible bool) (*PingPayload, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "PingPayload", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}
	itemID := unpackNumber(slice)
	innerSlice := slice[HeaderSizeUint:]

	switch itemID {

	case 0:
		_, err := PingFromSlice(innerSlice, compatible)
		if err != nil {
			return nil, err
		}

	case 1:
		_, err := PongFromSlice(innerSlice, compatible)
		if err != nil {
			return nil, err
		}

	default:
		return nil, errors.New("UnknownItem, PingPayload")
	}
	return &PingPayload{inner: slice}, nil
}

func (s *PingPayload) ItemID() Number {
	return unpackNumber(s.inner)
}
func (s *PingPayload) AsBuilder() PingPayloadBuilder {
	return *NewPingPayloadBuilder().Set(*s.ToUnion())
}

type PingMessageBuilder struct {
	payload PingPayload
}

func (s *PingMessageBuilder) Build() PingMessage {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (1 + 1)
	offsets := make([]uint32, 0, 1)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.payload.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.payload.AsSlice())
	return PingMessage{inner: b.Bytes()}
}

func (s *PingMessageBuilder) Payload(v PingPayload) *PingMessageBuilder {
	s.payload = v
	return s
}

func NewPingMessageBuilder() *PingMessageBuilder {
	return &PingMessageBuilder{payload: PingPayloadDefault()}
}

type PingMessage struct {
	inner []byte
}

func PingMessageFromSliceUnchecked(slice []byte) *PingMessage {
	return &PingMessage{inner: slice}
}
func (s *PingMessage) AsSlice() []byte {
	return s.inner
}

func PingMessageDefault() PingMessage {
	return *PingMessageFromSliceUnchecked([]byte{24, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0})
}

func PingMessageFromSlice(slice []byte, compatible bool) (*PingMessage, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "PingMessage", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "PingMessage", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "PingMessage", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "PingMessage", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "PingMessage", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
	if fieldCount < 1 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 1 {
		return nil, errors.New("FieldCountNotMatch")
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = PingPayloadFromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	return &PingMessage{inner: slice}, nil
}

func (s *PingMessage) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *PingMessage) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *PingMessage) Len() uint {
	return s.FieldCount()
}
func (s *PingMessage) IsEmpty() bool {
	return s.Len() == 0
}
func (s *PingMessage) CountExtraFields() uint {
	return s.FieldCount() - 1
}

func (s *PingMessage) HasExtraFields() bool {
	return 1 != s.FieldCount()
}

func (s *PingMessage) Payload() *PingPayload {
	var ret *PingPayload
	start := unpackNumber(s.inner[4:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[8:])
		ret = PingPayloadFromSliceUnchecked(s.inner[start:end])
	} else {
		ret = PingPayloadFromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *PingMessage) AsBuilder() PingMessageBuilder {
	ret := NewPingMessageBuilder().Payload(*s.Payload())
	return *ret
}

type PingBuilder struct {
	nonce Uint32
}

func (s *PingBuilder) Build() Ping {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (1 + 1)
	offsets := make([]uint32, 0, 1)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.nonce.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.nonce.AsSlice())
	return Ping{inner: b.Bytes()}
}

func (s *PingBuilder) Nonce(v Uint32) *PingBuilder {
	s.nonce = v
	return s
}

func NewPingBuilder() *PingBuilder {
	return &PingBuilder{nonce: Uint32Default()}
}

type Ping struct {
	inner []byte
}

func PingFromSliceUnchecked(slice []byte) *Ping {
	return &Ping{inner: slice}
}
func (s *Ping) AsSlice() []byte {
	return s.inner
}

func PingDefault() Ping {
	return *PingFromSliceUnchecked([]byte{12, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0})
}

func PingFromSlice(slice []byte, compatible bool) (*Ping, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "Ping", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "Ping", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "Ping", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "Ping", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "Ping", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
	if fieldCount < 1 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 1 {
		return nil, errors.New("FieldCountNotMatch")
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = Uint32FromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	return &Ping{inner: slice}, nil
}

func (s *Ping) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *Ping) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *Ping) Len() uint {
	return s.FieldCount()
}
func (s *Ping) IsEmpty() bool {
	return s.Len() == 0
}
func (s *Ping) CountExtraFields() uint {
	return s.FieldCount() - 1
}

func (s *Ping) HasExtraFields() bool {
	return 1 != s.FieldCount()
}

func (s *Ping) Nonce() *Uint32 {
	var ret *Uint32
	start := unpackNumber(s.inner[4:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[8:])
		ret = Uint32FromSliceUnchecked(s.inner[start:end])
	} else {
		ret = Uint32FromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *Ping) AsBuilder() PingBuilder {
	ret := NewPingBuilder().Nonce(*s.Nonce())
	return *ret
}

type PongBuilder struct {
	nonce Uint32
}

func (s *PongBuilder) Build() Pong {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (1 + 1)
	offsets := make([]uint32, 0, 1)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.nonce.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.nonce.AsSlice())
	return Pong{inner: b.Bytes()}
}

func (s *PongBuilder) Nonce(v Uint32) *PongBuilder {
	s.nonce = v
	return s
}

func NewPongBuilder() *PongBuilder {
	return &PongBuilder{nonce: Uint32Default()}
}

type Pong struct {
	inner []byte
}

func PongFromSliceUnchecked(slice []byte) *Pong {
	return &Pong{inner: slice}
}
func (s *Pong) AsSlice() []byte {
	return s.inner
}

func PongDefault() Pong {
	return *PongFromSliceUnchecked([]byte{12, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0})
}

func PongFromSlice(slice []byte, compatible bool) (*Pong, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "Pong", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "Pong", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "Pong", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "Pong", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "Pong", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
	if fieldCount < 1 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 1 {
		return nil, errors.New("FieldCountNotMatch")
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = Uint32FromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	return &Pong{inner: slice}, nil
}

func (s *Pong) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *Pong) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *Pong) Len() uint {
	return s.FieldCount()
}
func (s *Pong) IsEmpty() bool {
	return s.Len() == 0
}
func (s *Pong) CountExtraFields() uint {
	return s.FieldCount() - 1
}

func (s *Pong) HasExtraFields() bool {
	return 1 != s.FieldCount()
}

func (s *Pong) Nonce() *Uint32 {
	var ret *Uint32
	start := unpackNumber(s.inner[4:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[8:])
		ret = Uint32FromSliceUnchecked(s.inner[start:end])
	} else {
		ret = Uint32FromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *Pong) AsBuilder() PongBuilder {
	ret := NewPongBuilder().Nonce(*s.Nonce())
	return *ret
}
