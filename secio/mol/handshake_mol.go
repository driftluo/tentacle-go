// Generated by Molecule 0.8.0
// Generated by Moleculec-Go 0.1.11

package handshake

import (
	"bytes"
	"encoding/binary"
	"errors"
	"strconv"
	"strings"
)

type Number uint32

const HeaderSizeUint uint32 = 4

// Byte is the primitive type
type Byte [1]byte

func NewByte(b byte) Byte {
	return Byte([1]byte{b})
}
func ByteDefault() Byte {
	return Byte([1]byte{0})
}
func ByteFromSliceUnchecked(slice []byte) *Byte {
	b := new(Byte)
	b[0] = slice[0]
	return b
}
func (b *Byte) AsSlice() []byte {
	return b[:]
}
func ByteFromSlice(slice []byte, _compatible bool) (*Byte, error) {
	if len(slice) != 1 {
		return nil, errors.New("TotalSizeNotMatch")
	}
	b := new(Byte)
	b[0] = slice[0]
	return b, nil
}
func unpackNumber(b []byte) Number {
	bytesBuffer := bytes.NewBuffer(b)
	var x Number
	binary.Read(bytesBuffer, binary.LittleEndian, &x)
	return x
}
func packNumber(num Number) []byte {
	b := make([]byte, 4)
	binary.LittleEndian.PutUint32(b, uint32(num))
	return b
}

type Secp256k1Builder struct {
	inner []Byte
}

func (s *Secp256k1Builder) Build() Secp256k1 {
	size := packNumber(Number(len(s.inner)))

	b := new(bytes.Buffer)

	b.Write(size)
	len := len(s.inner)
	for i := 0; i < len; i++ {
		b.Write(s.inner[i].AsSlice())
	}

	sb := Secp256k1{inner: b.Bytes()}

	return sb
}

func (s *Secp256k1Builder) Set(v []Byte) *Secp256k1Builder {
	s.inner = v
	return s
}
func (s *Secp256k1Builder) Push(v Byte) *Secp256k1Builder {
	s.inner = append(s.inner, v)
	return s
}
func (s *Secp256k1Builder) Extend(iter []Byte) *Secp256k1Builder {
	for i := 0; i < len(iter); i++ {
		s.inner = append(s.inner, iter[i])
	}
	return s
}
func (s *Secp256k1Builder) Replace(index uint, v Byte) *Byte {
	if uint(len(s.inner)) > index {
		a := s.inner[index]
		s.inner[index] = v
		return &a
	}
	return nil
}

func NewSecp256k1Builder() *Secp256k1Builder {
	return &Secp256k1Builder{[]Byte{}}
}

type Secp256k1 struct {
	inner []byte
}

func Secp256k1FromSliceUnchecked(slice []byte) *Secp256k1 {
	return &Secp256k1{inner: slice}
}
func (s *Secp256k1) AsSlice() []byte {
	return s.inner
}

func Secp256k1Default() Secp256k1 {
	return *Secp256k1FromSliceUnchecked([]byte{0, 0, 0, 0})
}

func Secp256k1FromSlice(slice []byte, _compatible bool) (*Secp256k1, error) {
	sliceLen := len(slice)
	if sliceLen < int(HeaderSizeUint) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "Secp256k1", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}
	itemCount := unpackNumber(slice)
	if itemCount == 0 {
		if sliceLen != int(HeaderSizeUint) {
			errMsg := strings.Join([]string{"TotalSizeNotMatch", "Secp256k1", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(HeaderSizeUint))}, " ")
			return nil, errors.New(errMsg)
		}
		return &Secp256k1{inner: slice}, nil
	}
	totalSize := int(HeaderSizeUint) + int(1*itemCount)
	if sliceLen != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "Secp256k1", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}
	return &Secp256k1{inner: slice}, nil
}

func (s *Secp256k1) TotalSize() uint {
	return uint(HeaderSizeUint) + 1*s.ItemCount()
}
func (s *Secp256k1) ItemCount() uint {
	number := uint(unpackNumber(s.inner))
	return number
}
func (s *Secp256k1) Len() uint {
	return s.ItemCount()
}
func (s *Secp256k1) IsEmpty() bool {
	return s.Len() == 0
}

// if *Byte is nil, index is out of bounds
func (s *Secp256k1) Get(index uint) *Byte {
	var re *Byte
	if index < s.Len() {
		start := uint(HeaderSizeUint) + 1*index
		end := start + 1
		re = ByteFromSliceUnchecked(s.inner[start:end])
	}
	return re
}

func (s *Secp256k1) RawData() []byte {
	return s.inner[HeaderSizeUint:]
}

func (s *Secp256k1) AsBuilder() Secp256k1Builder {
	size := s.ItemCount()
	t := NewSecp256k1Builder()
	for i := uint(0); i < size; i++ {
		t.Push(*s.Get(i))
	}
	return *t
}

type BytesBuilder struct {
	inner []Byte
}

func (s *BytesBuilder) Build() Bytes {
	size := packNumber(Number(len(s.inner)))

	b := new(bytes.Buffer)

	b.Write(size)
	len := len(s.inner)
	for i := 0; i < len; i++ {
		b.Write(s.inner[i].AsSlice())
	}

	sb := Bytes{inner: b.Bytes()}

	return sb
}

func (s *BytesBuilder) Set(v []Byte) *BytesBuilder {
	s.inner = v
	return s
}
func (s *BytesBuilder) Push(v Byte) *BytesBuilder {
	s.inner = append(s.inner, v)
	return s
}
func (s *BytesBuilder) Extend(iter []Byte) *BytesBuilder {
	for i := 0; i < len(iter); i++ {
		s.inner = append(s.inner, iter[i])
	}
	return s
}
func (s *BytesBuilder) Replace(index uint, v Byte) *Byte {
	if uint(len(s.inner)) > index {
		a := s.inner[index]
		s.inner[index] = v
		return &a
	}
	return nil
}

func NewBytesBuilder() *BytesBuilder {
	return &BytesBuilder{[]Byte{}}
}

type Bytes struct {
	inner []byte
}

func BytesFromSliceUnchecked(slice []byte) *Bytes {
	return &Bytes{inner: slice}
}
func (s *Bytes) AsSlice() []byte {
	return s.inner
}

func BytesDefault() Bytes {
	return *BytesFromSliceUnchecked([]byte{0, 0, 0, 0})
}

func BytesFromSlice(slice []byte, _compatible bool) (*Bytes, error) {
	sliceLen := len(slice)
	if sliceLen < int(HeaderSizeUint) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "Bytes", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}
	itemCount := unpackNumber(slice)
	if itemCount == 0 {
		if sliceLen != int(HeaderSizeUint) {
			errMsg := strings.Join([]string{"TotalSizeNotMatch", "Bytes", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(HeaderSizeUint))}, " ")
			return nil, errors.New(errMsg)
		}
		return &Bytes{inner: slice}, nil
	}
	totalSize := int(HeaderSizeUint) + int(1*itemCount)
	if sliceLen != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "Bytes", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}
	return &Bytes{inner: slice}, nil
}

func (s *Bytes) TotalSize() uint {
	return uint(HeaderSizeUint) + 1*s.ItemCount()
}
func (s *Bytes) ItemCount() uint {
	number := uint(unpackNumber(s.inner))
	return number
}
func (s *Bytes) Len() uint {
	return s.ItemCount()
}
func (s *Bytes) IsEmpty() bool {
	return s.Len() == 0
}

// if *Byte is nil, index is out of bounds
func (s *Bytes) Get(index uint) *Byte {
	var re *Byte
	if index < s.Len() {
		start := uint(HeaderSizeUint) + 1*index
		end := start + 1
		re = ByteFromSliceUnchecked(s.inner[start:end])
	}
	return re
}

func (s *Bytes) RawData() []byte {
	return s.inner[HeaderSizeUint:]
}

func (s *Bytes) AsBuilder() BytesBuilder {
	size := s.ItemCount()
	t := NewBytesBuilder()
	for i := uint(0); i < size; i++ {
		t.Push(*s.Get(i))
	}
	return *t
}

type StringBuilder struct {
	inner []Byte
}

func (s *StringBuilder) Build() String {
	size := packNumber(Number(len(s.inner)))

	b := new(bytes.Buffer)

	b.Write(size)
	len := len(s.inner)
	for i := 0; i < len; i++ {
		b.Write(s.inner[i].AsSlice())
	}

	sb := String{inner: b.Bytes()}

	return sb
}

func (s *StringBuilder) Set(v []Byte) *StringBuilder {
	s.inner = v
	return s
}
func (s *StringBuilder) Push(v Byte) *StringBuilder {
	s.inner = append(s.inner, v)
	return s
}
func (s *StringBuilder) Extend(iter []Byte) *StringBuilder {
	for i := 0; i < len(iter); i++ {
		s.inner = append(s.inner, iter[i])
	}
	return s
}
func (s *StringBuilder) Replace(index uint, v Byte) *Byte {
	if uint(len(s.inner)) > index {
		a := s.inner[index]
		s.inner[index] = v
		return &a
	}
	return nil
}

func NewStringBuilder() *StringBuilder {
	return &StringBuilder{[]Byte{}}
}

type String struct {
	inner []byte
}

func StringFromSliceUnchecked(slice []byte) *String {
	return &String{inner: slice}
}
func (s *String) AsSlice() []byte {
	return s.inner
}

func StringDefault() String {
	return *StringFromSliceUnchecked([]byte{0, 0, 0, 0})
}

func StringFromSlice(slice []byte, _compatible bool) (*String, error) {
	sliceLen := len(slice)
	if sliceLen < int(HeaderSizeUint) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "String", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}
	itemCount := unpackNumber(slice)
	if itemCount == 0 {
		if sliceLen != int(HeaderSizeUint) {
			errMsg := strings.Join([]string{"TotalSizeNotMatch", "String", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(HeaderSizeUint))}, " ")
			return nil, errors.New(errMsg)
		}
		return &String{inner: slice}, nil
	}
	totalSize := int(HeaderSizeUint) + int(1*itemCount)
	if sliceLen != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "String", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}
	return &String{inner: slice}, nil
}

func (s *String) TotalSize() uint {
	return uint(HeaderSizeUint) + 1*s.ItemCount()
}
func (s *String) ItemCount() uint {
	number := uint(unpackNumber(s.inner))
	return number
}
func (s *String) Len() uint {
	return s.ItemCount()
}
func (s *String) IsEmpty() bool {
	return s.Len() == 0
}

// if *Byte is nil, index is out of bounds
func (s *String) Get(index uint) *Byte {
	var re *Byte
	if index < s.Len() {
		start := uint(HeaderSizeUint) + 1*index
		end := start + 1
		re = ByteFromSliceUnchecked(s.inner[start:end])
	}
	return re
}

func (s *String) RawData() []byte {
	return s.inner[HeaderSizeUint:]
}

func (s *String) AsBuilder() StringBuilder {
	size := s.ItemCount()
	t := NewStringBuilder()
	for i := uint(0); i < size; i++ {
		t.Push(*s.Get(i))
	}
	return *t
}

type PublicKeyBuilder struct {
	inner PublicKeyUnion
}

func NewPublicKeyBuilder() *PublicKeyBuilder {
	v := PublicKeyDefault()
	return &PublicKeyBuilder{inner: *v.ToUnion()}
}
func (s *PublicKeyBuilder) Set(v PublicKeyUnion) *PublicKeyBuilder {
	s.inner = v
	return s
}
func (s *PublicKeyBuilder) Build() PublicKey {
	b := new(bytes.Buffer)
	b.Write(packNumber(s.inner.itemID))
	b.Write(s.inner.AsSlice())

	return PublicKey{inner: b.Bytes()}
}

type PublicKey struct {
	inner []byte
}

func PublicKeyFromSliceUnchecked(slice []byte) *PublicKey {
	return &PublicKey{inner: slice}
}
func (s *PublicKey) AsSlice() []byte {
	return s.inner
}

func PublicKeyDefault() PublicKey {
	return *PublicKeyFromSliceUnchecked([]byte{0, 0, 0, 0, 0, 0, 0, 0})
}

type PublicKeyUnion struct {
	itemID Number
	inner  []byte
}

func (s *PublicKeyUnion) AsSlice() []byte {
	return s.inner
}
func (s *PublicKeyUnion) ItemID() Number {
	return s.itemID
}

func PublicKeyUnionFromSecp256k1(v Secp256k1) PublicKeyUnion {
	return PublicKeyUnion{itemID: 0, inner: v.AsSlice()}
}

func (s *PublicKeyUnion) IntoSecp256k1() *Secp256k1 {
	switch s.ItemID() {
	case 0:
		return Secp256k1FromSliceUnchecked(s.AsSlice())
	default:
		errMsg := strings.Join([]string{"invalid item_id: expect 0, found", strconv.Itoa(int(s.ItemID()))}, " ")
		panic(errMsg)
	}
}

func (s *PublicKeyUnion) ItemName() string {
	switch s.itemID {

	case 0:
		return "Secp256k1"

	default:
		panic("invalid data: PublicKeyUnion")
	}
}

func (s *PublicKey) ToUnion() *PublicKeyUnion {
	switch s.ItemID() {

	case 0:
		return &PublicKeyUnion{itemID: 0, inner: s.inner[HeaderSizeUint:]}

	default:
		panic("invalid data: PublicKey")
	}
}

func PublicKeyFromSlice(slice []byte, compatible bool) (*PublicKey, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "PublicKey", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}
	itemID := unpackNumber(slice)
	innerSlice := slice[HeaderSizeUint:]

	switch itemID {

	case 0:
		_, err := Secp256k1FromSlice(innerSlice, compatible)
		if err != nil {
			return nil, err
		}

	default:
		return nil, errors.New("UnknownItem, PublicKey")
	}
	return &PublicKey{inner: slice}, nil
}

func (s *PublicKey) ItemID() Number {
	return unpackNumber(s.inner)
}
func (s *PublicKey) AsBuilder() PublicKeyBuilder {
	return *NewPublicKeyBuilder().Set(*s.ToUnion())
}

type ProposeBuilder struct {
	rand      Bytes
	pubkey    Bytes
	exchanges String
	ciphers   String
	hashes    String
}

func (s *ProposeBuilder) Build() Propose {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (5 + 1)
	offsets := make([]uint32, 0, 5)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.rand.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.pubkey.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.exchanges.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.ciphers.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.hashes.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.rand.AsSlice())
	b.Write(s.pubkey.AsSlice())
	b.Write(s.exchanges.AsSlice())
	b.Write(s.ciphers.AsSlice())
	b.Write(s.hashes.AsSlice())
	return Propose{inner: b.Bytes()}
}

func (s *ProposeBuilder) Rand(v Bytes) *ProposeBuilder {
	s.rand = v
	return s
}

func (s *ProposeBuilder) Pubkey(v Bytes) *ProposeBuilder {
	s.pubkey = v
	return s
}

func (s *ProposeBuilder) Exchanges(v String) *ProposeBuilder {
	s.exchanges = v
	return s
}

func (s *ProposeBuilder) Ciphers(v String) *ProposeBuilder {
	s.ciphers = v
	return s
}

func (s *ProposeBuilder) Hashes(v String) *ProposeBuilder {
	s.hashes = v
	return s
}

func NewProposeBuilder() *ProposeBuilder {
	return &ProposeBuilder{rand: BytesDefault(), pubkey: BytesDefault(), exchanges: StringDefault(), ciphers: StringDefault(), hashes: StringDefault()}
}

type Propose struct {
	inner []byte
}

func ProposeFromSliceUnchecked(slice []byte) *Propose {
	return &Propose{inner: slice}
}
func (s *Propose) AsSlice() []byte {
	return s.inner
}

func ProposeDefault() Propose {
	return *ProposeFromSliceUnchecked([]byte{44, 0, 0, 0, 24, 0, 0, 0, 28, 0, 0, 0, 32, 0, 0, 0, 36, 0, 0, 0, 40, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func ProposeFromSlice(slice []byte, compatible bool) (*Propose, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "Propose", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "Propose", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "Propose", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "Propose", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "Propose", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
	if fieldCount < 5 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 5 {
		return nil, errors.New("FieldCountNotMatch")
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = BytesFromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BytesFromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = StringFromSlice(slice[offsets[2]:offsets[3]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = StringFromSlice(slice[offsets[3]:offsets[4]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = StringFromSlice(slice[offsets[4]:offsets[5]], compatible)
	if err != nil {
		return nil, err
	}

	return &Propose{inner: slice}, nil
}

func (s *Propose) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *Propose) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *Propose) Len() uint {
	return s.FieldCount()
}
func (s *Propose) IsEmpty() bool {
	return s.Len() == 0
}
func (s *Propose) CountExtraFields() uint {
	return s.FieldCount() - 5
}

func (s *Propose) HasExtraFields() bool {
	return 5 != s.FieldCount()
}

func (s *Propose) Rand() *Bytes {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return BytesFromSliceUnchecked(s.inner[start:end])
}

func (s *Propose) Pubkey() *Bytes {
	start := unpackNumber(s.inner[8:])
	end := unpackNumber(s.inner[12:])
	return BytesFromSliceUnchecked(s.inner[start:end])
}

func (s *Propose) Exchanges() *String {
	start := unpackNumber(s.inner[12:])
	end := unpackNumber(s.inner[16:])
	return StringFromSliceUnchecked(s.inner[start:end])
}

func (s *Propose) Ciphers() *String {
	start := unpackNumber(s.inner[16:])
	end := unpackNumber(s.inner[20:])
	return StringFromSliceUnchecked(s.inner[start:end])
}

func (s *Propose) Hashes() *String {
	var ret *String
	start := unpackNumber(s.inner[20:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[24:])
		ret = StringFromSliceUnchecked(s.inner[start:end])
	} else {
		ret = StringFromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *Propose) AsBuilder() ProposeBuilder {
	ret := NewProposeBuilder().Rand(*s.Rand()).Pubkey(*s.Pubkey()).Exchanges(*s.Exchanges()).Ciphers(*s.Ciphers()).Hashes(*s.Hashes())
	return *ret
}

type ExchangeBuilder struct {
	epubkey   Bytes
	signature Bytes
}

func (s *ExchangeBuilder) Build() Exchange {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (2 + 1)
	offsets := make([]uint32, 0, 2)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.epubkey.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.signature.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.epubkey.AsSlice())
	b.Write(s.signature.AsSlice())
	return Exchange{inner: b.Bytes()}
}

func (s *ExchangeBuilder) Epubkey(v Bytes) *ExchangeBuilder {
	s.epubkey = v
	return s
}

func (s *ExchangeBuilder) Signature(v Bytes) *ExchangeBuilder {
	s.signature = v
	return s
}

func NewExchangeBuilder() *ExchangeBuilder {
	return &ExchangeBuilder{epubkey: BytesDefault(), signature: BytesDefault()}
}

type Exchange struct {
	inner []byte
}

func ExchangeFromSliceUnchecked(slice []byte) *Exchange {
	return &Exchange{inner: slice}
}
func (s *Exchange) AsSlice() []byte {
	return s.inner
}

func ExchangeDefault() Exchange {
	return *ExchangeFromSliceUnchecked([]byte{20, 0, 0, 0, 12, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func ExchangeFromSlice(slice []byte, compatible bool) (*Exchange, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "Exchange", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "Exchange", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "Exchange", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "Exchange", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "Exchange", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
	if fieldCount < 2 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 2 {
		return nil, errors.New("FieldCountNotMatch")
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = BytesFromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BytesFromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	return &Exchange{inner: slice}, nil
}

func (s *Exchange) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *Exchange) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *Exchange) Len() uint {
	return s.FieldCount()
}
func (s *Exchange) IsEmpty() bool {
	return s.Len() == 0
}
func (s *Exchange) CountExtraFields() uint {
	return s.FieldCount() - 2
}

func (s *Exchange) HasExtraFields() bool {
	return 2 != s.FieldCount()
}

func (s *Exchange) Epubkey() *Bytes {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return BytesFromSliceUnchecked(s.inner[start:end])
}

func (s *Exchange) Signature() *Bytes {
	var ret *Bytes
	start := unpackNumber(s.inner[8:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[12:])
		ret = BytesFromSliceUnchecked(s.inner[start:end])
	} else {
		ret = BytesFromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *Exchange) AsBuilder() ExchangeBuilder {
	ret := NewExchangeBuilder().Epubkey(*s.Epubkey()).Signature(*s.Signature())
	return *ret
}
