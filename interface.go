package tentacle

const (
	// SessionClose a session close
	SessionClose uint = iota
	// SessionOpen a session open
	SessionOpen
	// ListenClose a listener close
	ListenClose
	// ListenStarted a listener started
	ListenStarted
)

// ServiceEvent event generated by the Service
type ServiceEvent struct {
	Tag   uint
	Event interface{}
}

const (
	// DialerError when dial remote error
	DialerError uint = iota
	// ListenError when listen error
	ListenError
	// ProtocolSelectError Protocol select fail
	ProtocolSelectError
	// ProtocolError Protocol error during interaction
	ProtocolError
	// SessionTimeout After initializing the connection, the session does not open any protocol,
	// suspected fd attack
	SessionTimeout
	// MuxerError Multiplex protocol error
	MuxerError
	// ProtocolHandleError protocol handle error, will cause memory leaks/abnormal CPU usage
	ProtocolHandleError
)

// ServiceErrorProtocolHandleErrorInner is inner msg of this error
type ServiceErrorProtocolHandleErrorInner struct {
	PID ProtocolID
	// If SID == 0, it means that can not locate which session case this error
	SID SessionID
}

// ServiceError error generated by the Service
type ServiceError struct {
	Tag   uint
	Event interface{}
}

// ServiceHandle is a handle to do something by service
//
// #### Behavior
//
// The handle that exists when the Service is created.
//
// Mainly handle some Service-level errors thrown at runtime, such as listening errors.
//
// At the same time, the session establishment and disconnection messages will also be perceived here.
type ServiceHandle interface {
	// Handling runtime errors
	HandleError(*ServiceContext, ServiceError)
	// Handling session establishment and disconnection events
	HandleEvent(*ServiceContext, ServiceEvent)
}

// ServiceProtocol is Service level protocol handle
//
// #### Behavior
//
// Define the behavior of each custom protocol in each state.
//
// Depending on whether the user defines a service handle or a session exclusive handle,
// the runtime has different performance.
//
// The **important difference** is that some state values are allowed in the service handle,
// and the handle exclusive to the session is "stateless", relative to the service handle,
// it can only retain the information between a protocol stream on and off.
//
// The opening and closing of the protocol will create and clean up the handle exclusive
// to the session, but the service handle will remain in the state until the service is closed.
//
type ServiceProtocol interface {
	// This function is called when the service start.
	//
	// The service handle will only be called once
	Init(*ProtocolContext)
	// Called when opening protocol
	Connected(*ProtocolContextRef, string)
	// Called when closing protocol
	Disconnected(*ProtocolContextRef)
	// Called when the corresponding protocol message is received
	Received(*ProtocolContextRef, []byte)
	// Called when the Service receives the notify task
	Notify(*ProtocolContext, uint64)
}

// SessionProtocol is Session level protocol handle
type SessionProtocol interface {
	// Called when opening protocol
	Connected(*ProtocolContextRef, string)
	// Called when closing protocol
	Disconnected(*ProtocolContextRef)
	// Called when the corresponding protocol message is received
	Received(*ProtocolContextRef, []byte)
	// Called when the session receives the notify task
	Notify(*ProtocolContextRef, uint64)
}
