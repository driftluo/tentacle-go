package tentacle

import (
	"fmt"
	"time"

	ma "github.com/multiformats/go-multiaddr"
	manet "github.com/multiformats/go-multiaddr/net"
)

const (
	// SessionClose a session close
	SessionClose uint = iota
	// SessionOpen a session open
	SessionOpen
	// ListenClose a listener close
	ListenClose
	// ListenStarted a listener started
	ListenStarted
)

// ServiceEvent event generated by the Service
type ServiceEvent struct {
	Tag   uint
	Event any
}

type serviceEventWrapper struct {
	event    ServiceEvent
	waitSign chan bool
}

// Name error tag name
func (s *ServiceEvent) Name() string {
	var r string
	switch s.Tag {
	case SessionClose:
		r = "SessionClose"

	case SessionOpen:
		r = "SessionOpen"

	case ListenClose:
		r = "ListenClose"

	case ListenStarted:
		r = "ListenStarted"
	}
	return r
}

func (s *ServiceEvent) String() string {
	var r string
	switch s.Tag {
	case SessionClose:
		inner := s.Event.(*SessionContext)
		r = fmt.Sprintf("SessionClose: sid %d", inner.Sid)

	case SessionOpen:
		inner := s.Event.(*SessionContext)
		r = fmt.Sprintf("SessionOpen: sid %d", inner.Sid)

	case ListenClose:
		inner := s.Event.(ma.Multiaddr)
		r = fmt.Sprintf("ListenClose: addr %s", inner)

	case ListenStarted:
		inner := s.Event.(ma.Multiaddr)
		r = fmt.Sprintf("ListenStarted: addr %s", inner)
	}
	return r
}

const (
	// DialerError when dial remote error
	DialerError uint = iota
	// ListenError when listen error
	ListenError
	// ProtocolSelectError Protocol select fail
	ProtocolSelectError
	// ProtocolError Protocol error during interaction
	ProtocolError
	// SessionTimeout After initializing the connection, the session does not open any protocol,
	// suspected fd attack
	SessionTimeout
	// MuxerError Multiplex protocol error
	MuxerError
	// ProtocolHandleError protocol handle error, will cause memory leaks/abnormal CPU usage
	ProtocolHandleError
)

// ProtocolHandleErrorInner is inner msg of this error
type ProtocolHandleErrorInner struct {
	PID ProtocolID
	// If SID == 0, it means that can not locate which session case this error
	SID SessionID
}

func (p *ProtocolHandleErrorInner) String() string {
	return fmt.Sprintf("protocol handle abnormally closed, session id: %d, pid %d", p.SID, p.PID)
}

// ProtocolSelectErrorInner protocol select fail
type ProtocolSelectErrorInner struct {
	// Protocol name, if none, timeout or other net problem,
	// if Some, don't support this proto
	Name string
	// Session context
	Context *SessionContext
}

func (p *ProtocolSelectErrorInner) String() string {
	return fmt.Sprintf("protocol select error, protocol name: %s, session id: %d", p.Name, p.Context.Sid)
}

// ProtocolErrorInner protocol error during interaction
type ProtocolErrorInner struct {
	SID SessionID
	PID ProtocolID
	// Codec error
	Err error
}

func (p *ProtocolErrorInner) String() string {
	return fmt.Sprintf("protocol error during interaction, pid: %d, sid: %d, error: %s", p.PID, p.SID, p.Err)
}

// SessionTimeoutInner after initializing the connection, the session does not open any protocol,
// suspected fd attack
type SessionTimeoutInner struct {
	Context *SessionContext
}

func (s *SessionTimeoutInner) String() string {
	return fmt.Sprintf("sid: %d, remote addr: %s", s.Context.Sid, s.Context.RemoteAddr)
}

// MuxerErrorInner multiplex protocol error
type MuxerErrorInner struct {
	Context *SessionContext
	Err     error
}

func (s *MuxerErrorInner) String() string {
	return fmt.Sprintf("sid: %d, remote addr: %s, error: %s", s.Context.Sid, s.Context.RemoteAddr, s.Err)
}

const (
	/*
		DialerErrorInner and ListenErrorInner tags
		but ListenErrorInner don't have `PeerIDNotMatch` and `HandshakeError` tag
	*/

	// RepeatedConnection connected to the connected peer, inner type SessionID
	RepeatedConnection uint = iota
	// PeerIDNotMatch when dial remote, peer id does not match
	PeerIDNotMatch
	// HandshakeError handshake error
	HandshakeError
	// TransportError transport error
	TransportError
	// IoError IO error
	IoError
)

// DialerErrorInner when dial remote error
type DialerErrorInner struct {
	Tag   uint
	Inner any
	// remote addr
	Addr ma.Multiaddr
}

// Name error tag name
func (d *DialerErrorInner) Name() string {
	var s string
	switch d.Tag {
	case RepeatedConnection:
		s = "RepeatedConnection"

	case PeerIDNotMatch:
		s = "PeerIDNotMatch"

	case HandshakeError:
		s = "HandshakeError"

	case TransportError:
		s = "TransportError"

	case IoError:
		s = "IoError"
	}
	return s
}

func (d *DialerErrorInner) String() string {
	var s string
	switch d.Tag {
	case RepeatedConnection:
		id := d.Inner.(SessionID)
		s = fmt.Sprintf("RepeatedConnection error: repeated by session %d, remote addr: %s", id, d.Addr)

	case PeerIDNotMatch:
		s = fmt.Sprintf("Peer id don't match by dail command, remote addr: %s", d.Addr)

	case HandshakeError:
		s = fmt.Sprintf("Handshake error: %s, remote addr: %s", d.Inner.(error), d.Addr)

	case TransportError:
		s = fmt.Sprintf("Transport error: %s, remote addr: %s", d.Inner.(error), d.Addr)

	case IoError:
		s = fmt.Sprintf("Io error: %s, remote addr: %s", d.Inner.(error), d.Addr)
	}
	return s
}

// ListenErrorInner when listen error
type ListenErrorInner struct {
	Tag   uint
	Inner any
	// Listen address
	Addr ma.Multiaddr
}

// Name error tag name
func (d *ListenErrorInner) Name() string {
	var s string
	switch d.Tag {
	case RepeatedConnection:
		s = "RepeatedConnection"

	case TransportError:
		s = "TransportError"

	case IoError:
		s = "IoError"
	}
	return s
}

func (d *ListenErrorInner) String() string {
	var s string
	switch d.Tag {
	case RepeatedConnection:
		id := d.Inner.(SessionID)
		s = fmt.Sprintf("RepeatedConnection error: repeated by session %d, remote addr: %s", id, d.Addr)

	case TransportError:
		s = fmt.Sprintf("Transport error: %s, remote addr: %s", d.Inner.(error), d.Addr)

	case IoError:
		s = fmt.Sprintf("Io error: %s, remote addr: %s", d.Inner.(error), d.Addr)
	}
	return s
}

// ServiceError error generated by the Service
type ServiceError struct {
	Tag   uint
	Event any
}

// Name error tag name
func (s *ServiceError) Name() string {
	var r string
	switch s.Tag {
	case DialerError:
		r = "DialerError"

	case ListenError:
		r = "ListenError"

	case ProtocolSelectError:
		r = "ProtocolSelectError"

	case ProtocolError:
		r = "ProtocolError"

	case SessionTimeout:
		r = "SessionTimeout"

	case MuxerError:
		r = "MuxerError"

	case ProtocolHandleError:
		r = "ProtocolHandleError"
	}
	return r
}

func (s *ServiceError) String() string {
	var r string
	switch s.Tag {
	case DialerError:
		inner := s.Event.(DialerErrorInner)
		r = fmt.Sprintf("DialerError: %s", inner.String())

	case ListenError:
		inner := s.Event.(ListenErrorInner)
		r = fmt.Sprintf("ListenError: %s", inner.String())

	case ProtocolSelectError:
		inner := s.Event.(ProtocolSelectErrorInner)
		r = fmt.Sprintf("ProtocolSelectError: %s", inner.String())

	case ProtocolError:
		inner := s.Event.(ProtocolErrorInner)
		r = fmt.Sprintf("ProtocolError: %s", inner.String())

	case SessionTimeout:
		inner := s.Event.(SessionTimeoutInner)
		r = fmt.Sprintf("SessionTimeout: %s", inner.String())

	case MuxerError:
		inner := s.Event.(MuxerErrorInner)
		r = fmt.Sprintf("MuxerError: %s", inner.String())

	case ProtocolHandleError:
		inner := s.Event.(ProtocolHandleErrorInner)
		r = fmt.Sprintf("ProtocolHandleError: %s", inner.String())
	}
	return r
}

// ServiceHandle is a handle to do something by service
//
// #### Behavior
//
// The handle that exists when the Service is created.
//
// Mainly handle some Service-level errors thrown at runtime, such as listening errors.
//
// At the same time, the session establishment and disconnection messages will also be perceived here.
type ServiceHandle interface {
	// Handling runtime errors
	HandleError(*ServiceContext, ServiceError)
	// Handling session establishment and disconnection events
	HandleEvent(*ServiceContext, ServiceEvent)
}

// ServiceProtocol is Service level protocol handle
//
// #### Behavior
//
// Define the behavior of each custom protocol in each state.
//
// Depending on whether the user defines a service handle or a session exclusive handle,
// the runtime has different performance.
//
// The **important difference** is that some state values are allowed in the service handle,
// and the handle exclusive to the session is "stateless", relative to the service handle,
// it can only retain the information between a protocol stream on and off.
//
// The opening and closing of the protocol will create and clean up the handle exclusive
// to the session, but the service handle will remain in the state until the service is closed.
type ServiceProtocol interface {
	// This function is called when the service start.
	//
	// The service handle will only be called once
	Init(*ProtocolContext)
	// Called when opening protocol
	Connected(ctx *ProtocolContextRef, version string)
	// Called when closing protocol
	Disconnected(*ProtocolContextRef)
	// Called when the corresponding protocol message is received
	Received(ctx *ProtocolContextRef, data []byte)
	// Called when the Service receives the notify task
	Notify(ctx *ProtocolContext, token uint64)
}

// SessionProtocol is Session level protocol handle
type SessionProtocol interface {
	// Called when opening protocol
	Connected(ctx *ProtocolContextRef, version string)
	// Called when closing protocol
	Disconnected(*ProtocolContextRef)
	// Called when the corresponding protocol message is received
	Received(ctx *ProtocolContextRef, data []byte)
	// Called when the session receives the notify task
	Notify(ctx *ProtocolContextRef, token uint64)
}

// SubstreamReadPart is the read part for the protocol side
type SubstreamReadPart interface {
	// Get next message
	NextMsg() (msg []byte, err error)
	// Get protocol id
	ProtocolID() ProtocolID
	// Get protocol version
	Version() string
}

// When the negotiation is completed and the agreement is opened, will call the implementation,
// allow users to implement the read processing of the protocol by themselves
//
// Implementing this interface means that streaming reading directly from the underlying substream
// will become possible
//
// This interface implementation and the callback implementation are mutually exclusive, and will be
// checked during construction, if both exist, it will panic
type ProtocolSpawn interface {
	// Spawn call on protocol opened
	// It is assumed that the user will use the go syntax internally to put the Reader in a separate goroutine for execution
	Spawn(ctx *SessionContext, control *Service, read SubstreamReadPart)
}

const (
	taskProtocolMessage uint = iota
	taskRawSession
	taskProtocolOpen
	taskProtocolClose
	taskSetProtocolNotify
	taskRemoveProtocolNotify
	taskSetProtocolSessionNotify
	taskRemoveProtocolSessionNotify
	taskDisconnect
	taskDial
	taskListen
	taskListenStart
	taskShutdown
)

// Task received by the Service.
//
// An instruction that the outside world can send to the service
type serviceTask struct {
	tag   uint
	event any
}

type taskProtocolMessageInner struct {
	target TargetSession
	pid    ProtocolID
	data   []byte
}

type taskProtocolOpenInner struct {
	sid    SessionID
	target TargetProtocol
}

type taskProtocolCloseInner struct {
	sid SessionID
	pid ProtocolID
}

type taskDialInner struct {
	addr   ma.Multiaddr
	target TargetProtocol
}

type taskSetProtocolNotifyInner struct {
	pid      ProtocolID
	interval time.Duration
	token    uint64
}

type taskRemoveProtocolNotifyInner struct {
	pid   ProtocolID
	token uint64
}

type taskSetProtocolSessionNotifyInner struct {
	sid      SessionID
	pid      ProtocolID
	interval time.Duration
	token    uint64
}

type taskRemoveProtocolSessionNotifyInner struct {
	sid   SessionID
	pid   ProtocolID
	token uint64
}

type taskRawSessionInner struct {
	conn manet.Conn
	info RawSessionInfo
}

type RawSessionInfo struct {
	ty   SessionType
	info any
}

// When RwSession is outbound, which protocol to open
func NewOutbound(targetProtocol TargetProtocol) RawSessionInfo {
	return RawSessionInfo{
		ty:   SessionType(0),
		info: targetProtocol,
	}
}

// When RwSession is inbound, which listen address is it come from
func NewInbound(listen_addr ma.Multiaddr) RawSessionInfo {
	return RawSessionInfo{
		ty:   SessionType(1),
		info: listen_addr,
	}
}
